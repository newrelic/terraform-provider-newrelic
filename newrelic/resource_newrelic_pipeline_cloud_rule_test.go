//go:build integration || NGEP
// +build integration NGEP

package newrelic

import (
	"context"
	"fmt"
	"os"
	"testing"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/acctest"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/resource"
	"github.com/hashicorp/terraform-plugin-sdk/v2/terraform"

	"github.com/newrelic/newrelic-client-go/v2/pkg/pipelinecontrol"
)

// TestAccNewRelicPipelineCloudRule_Basic tests the essential lifecycle (Create, Import, Delete) of the resource.
// An Update test is not included because all configurable attributes are marked with `ForceNew`,
// meaning any change will trigger a replacement (destroy and create) rather than an in-place update.
func TestAccNewRelicPipelineCloudRule_Basic(t *testing.T) {
	t.Parallel()

	var (
		ruleName        = fmt.Sprintf("test-rule-%s", acctest.RandString(10))
		ruleDescription = "This is a test pipeline cloud rule generated by an acceptance test."
		ruleNRQL        = "DELETE FROM Log where name = 'test-client-go-terraform'"
		resourceName    = "newrelic_pipeline_cloud_rule.foo"

		ruleNameUpdated        = fmt.Sprintf("test-rule-updated-%s", acctest.RandString(10))
		ruleDescriptionUpdated = "This is a test pipeline cloud rule generated by an acceptance test, updated."
		ruleNRQLUpdated        = "DELETE FROM Log where name = 'test-client-go-terraform-updated'"
	)

	resource.Test(t, resource.TestCase{
		PreCheck: func() {
			testAccPreCheck(t)
			if v := os.Getenv("NEW_RELIC_ACCOUNT_ID"); v == "" {
				t.Skip("NEW_RELIC_ACCOUNT_ID must be set for acceptance tests")
			}
		},
		Providers:    testAccProviders,
		CheckDestroy: testAccCheckNewRelicPipelineCloudRuleDestroy,
		Steps: []resource.TestStep{
			// Test: Create
			{
				Config: testAccPipelineCloudRuleConfig(ruleName, ruleDescription, ruleNRQL),
				Check: resource.ComposeTestCheckFunc(
					// Check if the resource exists in New Relic via API
					testAccCheckNewRelicPipelineCloudRuleExists(resourceName),
					// Check if the attributes in Terraform state match the configured values
					resource.TestCheckResourceAttr(resourceName, "name", ruleName),
					resource.TestCheckResourceAttr(resourceName, "description", ruleDescription),
					resource.TestCheckResourceAttr(resourceName, "nrql", ruleNRQL),
					resource.TestCheckResourceAttrSet(resourceName, "account_id"),
				),
			},
			// Test: Update
			{
				Config: testAccPipelineCloudRuleConfig(ruleNameUpdated, ruleDescriptionUpdated, ruleNRQLUpdated),
				Check: resource.ComposeTestCheckFunc(
					// Check if the resource exists in New Relic via API
					testAccCheckNewRelicPipelineCloudRuleExists(resourceName),
					// Check if the attributes in Terraform state match the configured values
					resource.TestCheckResourceAttr(resourceName, "name", ruleNameUpdated),
					resource.TestCheckResourceAttr(resourceName, "description", ruleDescriptionUpdated),
					resource.TestCheckResourceAttr(resourceName, "nrql", ruleNRQLUpdated),
					resource.TestCheckResourceAttrSet(resourceName, "account_id"),
				),
			},
			// Test: Import
			{
				ResourceName:      resourceName,
				ImportState:       true,
				ImportStateVerify: true,
				//ImportStateVerifyIgnore: []string{"entity_version"},
			},
		},
	})
}

// testAccCheckNewRelicPipelineCloudRuleDestroy verifies that the pipeline cloud rule resource
// has been successfully destroyed in New Relic.
func testAccCheckNewRelicPipelineCloudRuleDestroy(s *terraform.State) error {
	client := testAccProvider.Meta().(*ProviderConfig).NewClient

	for _, rs := range s.RootModule().Resources {
		if rs.Type != "newrelic_pipeline_cloud_rule" {
			continue
		}

		// Attempt to fetch the entity by its ID after the destroy operation.
		_, err := client.Pipelinecontrol.GetEntityWithContext(context.Background(), rs.Primary.ID)

		// An error from the API call is expected, as it indicates the entity was not found.
		if err != nil {
			return nil // Success: The resource has been destroyed.
		}

		// If no error occurs, the entity still exists, which is a failure for the destroy check.
		return fmt.Errorf("pipeline cloud rule '%s' still exists", rs.Primary.ID)
	}

	return nil
}

// testAccCheckNewRelicPipelineCloudRuleExists verifies that the pipeline cloud rule resource
// has been created in New Relic by querying the API.
func testAccCheckNewRelicPipelineCloudRuleExists(resourceName string) resource.TestCheckFunc {
	return func(s *terraform.State) error {
		rs, ok := s.RootModule().Resources[resourceName]
		if !ok {
			return fmt.Errorf("not found in state: %s", resourceName)
		}

		if rs.Primary.ID == "" {
			return fmt.Errorf("no pipeline cloud rule ID is set in state")
		}

		client := testAccProvider.Meta().(*ProviderConfig).NewClient
		resp, err := client.Pipelinecontrol.GetEntityWithContext(context.Background(), rs.Primary.ID)
		if err != nil {
			return fmt.Errorf("error fetching pipeline cloud rule with ID %s: %w", rs.Primary.ID, err)
		}

		if resp == nil {
			return fmt.Errorf("entity with ruleID %s returned nil response", rs.Primary.ID)
		}

		// Verify the fetched entity is of the correct type.
		if _, ok := (*resp).(*pipelinecontrol.EntityManagementPipelineCloudRuleEntity); !ok {
			return fmt.Errorf("entity %s is not of type EntityManagementPipelineCloudRuleEntity", rs.Primary.ID)
		}

		return nil
	}
}

// testAccPipelineCloudRuleConfig is a helper function to generate the HCL configuration
// for a newrelic_pipeline_cloud_rule resource.
func testAccPipelineCloudRuleConfig(name, description, nrql string) string {
	return fmt.Sprintf(`
resource "newrelic_pipeline_cloud_rule" "foo" {
  name        = "%s"
  description = "%s"
  nrql        = "%s"
}
`, name, description, nrql)
}
